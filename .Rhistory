}
my_vector()
length()
my_mean <- function(my_vector) {
c(1,2,3)
}
my_vector()
length()
?function
my_mean <- function(average) {
(c(1,2,3))
}
average("my_vector")
print()
my_mean <- function(average) {
(c(1,2,3))
}
average()
?function
skip()
swirl()
submit()
sum()
sum(c(1,2,3))
length(x)
length()
length(sum)
length("my_vector")
my_mean <- sum(x) {
sum(x,... ,na.rm =FALSE)
# Remember: the last expression evaluated will be returned!
}
install.packages("swirl")
library("swirl")
ls()
rm(list=ls())
install_from_swirl("R Programming")
swirl()
Sys.Date()
mean(c(2,4,5))
boring_function <- function(x) {
x
}
boring_function()
x(2)
boring_function <- function(x) {
x
}
x(2)
boring_function <- function(x) {
x
}
submit()
boring_function("My first function!")
boring_function()
boring_function
my_mean <- function(my_vector) {
my_vector=sum(x,na.rm = FALSE)/length(x)
}
submit()
sum(c(1,2,3),na.rm = FALSE)
length(c(1,2,3))
my_mean(my_vector = sum(c(1,2,3).na.rm=FALSE)/length(c(1,2,3))
my_mean(my_vector = sum(c(1,2,3))/length(c(1,2,3))
my_mean(my_vector = sum(c(1,2,3))/length(c(1,2,3)))
submit()
my_mean
my_vector()
my_mean<-function(my_vector){
#average of all numbers in my_vector
sum(c(x1,x2,x3),na.rm=FALSE)
length(c(x1,x2,x3))
my_vector=sum(c(x1,x2,x3)/length(c(x1,x2,x3))
}
my_mean<-function(sum,length){
sum(c(1,2,3))/length(c(1,2,3))
}
my_mean(my_vector = sum(c(1,2,3).na.rm=FALSE)/length(c(1,2,3))
submit()
my_mean<-function(sum,length){
sum(c(1,2,3))/length(c(1,2,3))
}
my_mean
info()
skip()
my_mean <- function(my_vector) {
# Write your code here!
# Remember: the last expression evaluated will be returned!
sum(my_vector)/length(my_vector)
}
my_mean(c(4,5,10))
remainder <- function(num, divisor) {
# Write your code here!
num %% divisor
# Remember: the last expression evaluated will be returned!
}
remainder(15,2)
remainder(126,8)
submit()
remainder(7,4)
submit()
remainder(7,2)
submit()
remainder(5,2)
submit()
remainder(567,9)
submit()
info()
skip()
remainder(5)
remainder(11,5)
remainder(divisor = 11,num = 5)
remainder(4,div=2)
args(remainder)
add_two_numbers <- function(num1, num2){
num1 + num2
}
add_two_numbers(556,895)
add_two_numbers()
add_two_numbers
add_two_numbers(2356,10102)
submit()
add_two_numbers
submit()
multiply_two_numbers <- function(num1, num2) {
num1 * num2
}
multiply_two_numbers(54,36)
multiply_two_numbers
submit()
info()
skip()
evaluate(c(1.4,3.6,7.9,8.8))
evaluate <- function(func, dat){
# Write your code here!
func(c(2,4,6))
# Remember: the last expression evaluated will be returned!
func(sum(c(2,4,6)))
}
evaluate()
evaluate(func,dat)
evaluate(func = c(2,4,6), dat = )
info()
skip()
evaluate(func, dat)
evaluate(function(x){x+1},6)
evaluate()
evaluate(func = c(8,4,0),x)
evaluate(c(8,4,0),)
skip()
evaluate(function(x),c(8,4,0))
info()
skip()
paste()
?paste
paste("Programming","is","fun!",collapse = NULL)
simon_says <- function(...){
paste("Simon says:", ...)
}
simon_says(...)
simon_says()
telegram <- function(...){
paste("START Good morning STOP",...)
}
telegram()
submit()
telegram
submit()
telegram()
submit()
info()
skip()
paste("START", ..., "STOP")
}
paste("START",...,"STOP",sep = "",collapse = NULL)
telegram <- function(...){
paste("START", ..., "STOP",sep = " ", collapse = NULL)
}
telegram("Good","Morning")
submit ()
ellipsis()
mad_libs <- function(...){
# Do your argument unpacking here!
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.",sep = " ",collapse = NULL)
}
mad_libs()
mad_libs
mad_libs(...)
mad_libs <- function(...){
# Do your argument unpacking here!
alpha <- args[["alpha"]]
beta  <- args[["beta"]]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.",sep = " ",collapse = NULL)
}
mad_libs()
mad_libs <- function(...){
# Do your argument unpacking here!
alpha <- args[["alpha"]]
beta  <- args[["beta"]]
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from","today where","students took to the streets in protest of the new","being installed on campus.",sep = " ",collapse = NULL)
}
mad_libs()
mad_libs <- function(...){
# Do your argument unpacking here!
# Don't modify any code below this comment.
# Notice the variables you'll need to create in order for the code below to
# be functional!
paste("News from","today where","students took to the streets in protest of the new","being installed on campus.",sep = " ",collapse = NULL)
}
mad_libs()
submit()
list()
paste()
info()
skip()
mad_libs()
"%p%" <- function(){
# Remember to add arguments!
"Good" %p% "job!"
}
%p%()
%p%
submit()
info()
skip()
"%p%" <- function(left, right){ # Remember to add arguments!
paste(left, right)
}
"%p%" <- function(...) { # Remember to add arguments!
paste("I", "love', " R!")
}
"%p%" <- function(...) {# Remember to add arguments!
paste("I", "love", "R!")
}
info()
skip()
d1<-Sys.Date()
class()
class(d1)
unclass(d1)
print(d1)
d1
d2<-as.Date(1969.01.01)
d2<-as.date("1969.01.01")
d2<-as.Date("1969.01.01")
info()
skip()
unclass(d2)
t1<-Sys.time("2008.26.03")
class(t1)
t1<-Sys.time("2008.03.26")
sys.time()
install.packages('swirl')
library("swirl")
ls()
rm(list=ls())
install_from_swirl("R Programming")
swirl()
sapply(flags,unique)
vapply(flags,unique,numeric(1))
FUN(X[[1]])
function([[1]])
OK()
ok()
sapply(flags, class)
vapply(flags, class,character(1))
?tapply
table(flags$ landmass)
table(flags$ animate)
tapply(flags$animate, flags$landmass, mean)
tapply(flags$population, flags$red, summary)
tapply(flags$population, flags$landmass, summary)
swirl()
0
data()
data(AirPassengers)
AirPassengers
summary(AirPassengers)
sapply(1949, Jan)
sapply(jan, 1949)
mean(1949)
tapply(Jan $1949,mean)
table(Jan$ 1949)
mean(AirPassengers)
q()
data("iris")
iris
iris(sepallength,mean)
iris(sepal.length,mean)
iris(sepal.length$,mean)
iris(sepal.length$,max)
iris(sepal.length$species,max)
iris<- readLines(iris)
dim(iris)
str(iris)
names(iris)[1:30]
names(iris)[1:5]
subset<-select(iris, Sepal.Length:Species)
subset<-select.list(iris, Sepal.Length:Species)
subset <-select(iris, 1:4)
subset<-select(iris, Sepal.Length:Species)
head(subset)
iris <-arrange(iris,sepal )
head(iris[1:15],3)
data("iris")
iris
head(iris[1:16],3)
head(iris[,1:5],3)
head(iris[,1:5],15)
head(iris[1:5,5],15)
head(iris[1:5,2],15)
library(datasets)
data("iris")
str(iris)
head(iris)
virginica<-subset(iris,species == "virginica")
Virginica<-subset(iris,species == "Virginica")
virginica<-subset(iris,Species == 'virginica')
sl<-data.frame(virginica$Sepal.Length)
sl<-data.frame(iris$Sepal.Length[iris$Species=="virginica"])
sl
Summary(s1)
summary(sl)
data("mtcars")
str(mtcars)
head(mtcars)
abs(mean(split(mtcars, mtcars$cyl)$'4'$hp) - mean(split(mtcars, mtcars$cyl)$'8'$hp))
makeCacheMatrix <- function(x = matrix()) {
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setInverse <- function(inverse) inv <<- inverse
getInverse <- function() inv
list(set = set,
get = get,
setInverse = setInverse,
getInverse = getInverse)
}
source("C:/Users/Gunjan/Desktop/coursera/R Programming/ProgrammingAssignment2-master")
source("C:/Users/Gunjan/Desktop/coursera/R Programming/ProgrammingAssignment2-master/cachematrix.R")
my_matrix<-makeCacheMatrix(matrix(1:6),2,3)
my_matrix<-makeCacheMatrix(matrix(1:4),2,2)
my_matrix<-makeCacheMatrix(matrix(1:4), 2, 2)
source("ProgrammingAssignment2/cachematrix.R")
source("C:/Users/Gunjan/Desktop/coursera/R Programming/ProgrammingAssignment2-master/cachematrix.R")
my_matrix <- makeCacheMatrix(matrix(1:4, 2, 2))
my_matrix$get()
my_matrix$getInverse()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
inv <- x$getInverse()
if (!is.null(inv)) {
message("getting cached data")
return(inv)
}
mat <- x$get()
inv <- solve(mat, ...)
x$setInverse(inv)
inv
}
cacheSolve(my_matrix)
my_matrix$getInverse()
my_matrix$set(matrix(c(2,2,1,4),2,2))
my_matrix$get()
my_matrix$get()
my_matrix$getInverse()
cacheSolve(my_matrix)
cacheSolve(my_matrix)getting cached data()
my_matrix$getInverse()
set.seed(1)
rpois(5,2)
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
set.seed(10)
x <- rep(0:1, each = 5)
e <- rnorm(10, 0, 20)
y <- 0.5 + 2 * x + e
x()
library(datasets)
Rprof()
fit <- lm(y ~ x1 + x2)
Rprof(NULL)
summary(Rproof)
setwd("C:/Users/Gunjan/Documents/GitHub/programassignment2-Lopamudrasatpathy/ProgrammingAssignment2")
getwd()
rm(list = ls())
makeCacheMatrix <-function( x = matrix()) {
nra <- NULL
set <- function(y) {
x <<- y
nra <<- NULL
}
get <- function() x
setinverse <- function(inverse) nra <<-inverse
getinverse <- function() nra
list(set = set , get = get ,
setinverse = setinverse ,
getinverse = getinverse )
}
## The second function "cacheSolve" computes the inverse of the special matrix returned by "makeCacheMatrix".
## It first check whether the inverse has been calculated,if so, then it gets the value from cache and skip computation.
## Or else , it calculates the inverse , set the value in the cache via setinverse function.
## Assume that matrix supplied is always invertible.
cacheSolve <-function(x = matrix(), ...)  {
nra <- x$getinverse()
if(!is.null(nra)) {
message("getting cached data")
return(nra)
}
matrix <- x$get()
nra <- solve(matrix, ...)
x$setinverse(nra)
nra
}
nra <- matrix(c(1,2,3,4,5,6,7,8,9),3,3)
nra
nra = makeCacheMatrix(x = matrix())
nra$get()
nra = cacheSolve(x = matrix())
nra1 = cacheSolve(x = matrix())
cacheSolve <-function(x = matrix(), ...)  {
nra <- x$getinverse
if(!is.null(nra)) {
message("getting cached data")
return(nra)
}
matrix <- x$get()
nra <- solve(matrix, ...)
x$setinverse(nra)
nra
}
nra = cacheSolve(x = matrix())
cacheSolve <-function(x = matrix(), ...)  {
nra <- x$getinverse
if(!is.null(nra)) {
message("getting cached data")
return(nra)
}
matrix <- x$get
nra <- solve(matrix, ...)
x$setinverse(nra)
nra
}
nra <- matrix(c(1,2,3,4),2,2)
nra
nra<- makeCacheMatrix(x = matrix())
nra$get()
nra<- cacheSolve(x= matrix())
nra$getinverse()
cacheSolve(nra)
nra <- x$getinverse()
cacheSolve <-function(x = matrix(), ...)  {
nra <- x$getinverse()
if(!is.null(nra)) {
message("getting cached data")
return(nra)
}
matrix <- x$get
nra <- solve(matrix, ...)
x$setinverse(nra)
nra
}
cacheSolve(nra)
nra <-matrix(c(1,2,3,5),2,2)
nra
cacheSolve(nra)
cacheSolve <-function(x = matrix(), ...)  {
nra <- x$getinverse
if(!is.null(nra)) {
message("getting cached data")
return(nra)
}
matrix <- x$get
nra <- solve(matrix, ...)
x$setinverse(nra)
nra
}
nra <- matrix(c(1,2,3,8),2,2)
nra
cacheSolve(x = matrix())
nra <- cacheSolve()
nra <- cacheSolve(x = matrix())
cacheSolve(nra)
nra = makeCacheMatrix(x = matrix())
nra$get()
nra$getinverse()
cacheSolve(nra)
nra<- matrix(c(2,5,7,-4,12,-4,-7,8,-9),3,3)
nra
nra = makeCacheMatrix(x = matrix())
nra$get()
nra$getinverse()
cacheSolve(nra)
cacheSolve(nra)
nra = makeCacheMatrix(x)
nra
nra = cacheSolve()
nra=cacheSolve(x)
