## The two functions below  form two cooperating parts.
## Function 'makeCacheMatrix()' generates a caching object
## to be consumed by function 'cacheSolve()'. 
##
## Typical use:
## x <- makeCacheMatrix(m)
## mi <- cacheSolve(x)
## where 'm' is a square and non-singular matrix, and
## 'mi' its calculated inverse.
## 'x', the caching object, contains a list of four functions, and 
## its environment caching values for a matrix and its inverse.
## 
## Suitable test matrices of any size 'n * n' can easily be generated by
## m <- matrix(rnorm(n^2),n), the integer 'n'

## The function 'makeCacheMatrix' generates a list object with an environment
## caching the argument matrix and its inverse. The list contains four 
## helper functions that cache (set) and uncache (get) those items.

makeCacheMatrix <- function(x = matrix()) {
    m <- NULL  
    set <- function(y) {
        x <<- y
        m<<- NULL
    }
    get <- function() x
    setInverse <- function(inverse) m <<- inverse
    getInverse <- function() m
    list(set = set, get = get, 
         setInverse = setInverse, 
         getInverse = getInverse)
}


## Write a short comment describing this function
## Function 'cacheSolve()' takes the caching object as its argument
## together with an optional '...' construct for potential modifiers
## of the contained 'solve()' function.
## If 'cacheSolve' finds that the cache already contains an inverse,
## it returns it. Otherwise, it calculates the inverse of the cached
## input matrix, caches the result, and returns it.
## The function returns an error message if the input matrix
## is not square, or is singular.

cacheSolve <- function(x, ...) {
        ## Return a matrix that is the inverse of 'x'
    m <- x$getInverse()
    if (!is.null(m)){
        message("getting cached inverse")
        return (m)
    }
    data <- x$get()                 
    m <- solve(data,...)      
    x$setInverse(m)    
    m                 
}
